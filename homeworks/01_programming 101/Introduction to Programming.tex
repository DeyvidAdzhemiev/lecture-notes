\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{url}
\usepackage[bulgarian]{babel}
\usepackage{listings}
\usepackage{enumerate}
\usepackage[framemethod=tikz]{mdframed}
\usepackage{enumitem}
\usepackage{relsize}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning,calc}

\captionsetup{font=footnotesize}

\lstset{breaklines=true}

\setenumerate[1]{label=\thesection.\arabic*.}
\setenumerate[2]{label*=\arabic*.}

\newcommand{\code}[1]{\texttt{#1}}

\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\tikzset{
block/.style = {draw, fill=white, rectangle,align = center},
entry/.style = {draw, fill=black, circle, radius=3em},
condition/.style = {draw, fill=white, diamond, align = center,node distance=3cm},
fork/.style = {draw, fill=black, circle,inner sep=1pt},
}


\author{\textit{email: kalin@fmi.uni-sofia.bg}}
\title{\textsc{Задачи за задължителна самоподготовка} \\
по \\
Увод в програмирането}


\begin{document}
\maketitle

\tableofcontents

\pagebreak

\small{Някои от задачите по-долу са решени в сборника \cite{sbornik}\textit{Магдалина Тодорова, Петър Армянов, Дафина Петкова, Калин Георгиев, ``Сборник от задачи по програмиране на C++. Първа част. Увод в програмирането''}. За задачите от сборника е посочена номерацията им от сборника.}

\pagebreak


\section {Увод, основи и примери}

\subsection {Основни примери}

\begin{enumerate}

	\item Превърнете рожденната си дата шестнадесетична, в осмична и в двоична бройни системи.

	\item Как бихте кодирали вашето име само с числа? Измислете собствено представяне на символни константи чрез редици от числа и запишете името си в това представяне.

	Разгледайте стандартната ASCii таблица (\code{http://www.asciitable.com/}) и запишете името си чрез серия от ASCii кодове.

\end{enumerate}

\subsection {Променливи, вход и изход, логически и аритметични операции, условен оператор}

\begin{enumerate}[resume]

	\item Задача 1.6.\cite{sbornik} Да се напише програма, която по зададени навършени години намира приблизително броя на дните, часовете, минутите и секундите, които е живял човек до навършване на зададените години.

	\item Задача 1.7.\cite{sbornik} Да се напише програма, която намира лицето на триъгълник по дадени: а) дължини на страна и височина към нея; б) три страни.


	\item Задача 2.7.\cite{sbornik} Да се напише програма, която въвежда координатите на точка от равнина и извежда на кой квадрант принадлежи тя. Да се разгледат случаите, когато точката принадлежи на някоя от координатните оси или съвпада с центъра на координатната система.

	\item Задача 1.14.\cite{sbornik} Да се запише булев израз, който да има стойност истина, ако посоченото условие е вярно и стойност - лъжа, в противен случай:

	\renewcommand{\theenumii}{\Alph{enumii}}

	\begin{enumerate}[label=\alph*)]%[a)] % a), b), c), ...
			 \item цялото число p се дели на 4 или на 7;
			 \item уравнението $ax^2 + bx + c = 0 (a \neq 0)$ няма реални корени;
			 \item точка с координати (a, b) лежи във вътрешността на кръг с радиус 5 и център (0, 1); г) точка с координати (a, b) лежи извън кръга с център (c, d) и радиус f;
			 \item точка принадлежи на частта от кръга с център (0, 0) и радиус 5 в трети квадрант;
			 \item точка принадлежи на венеца с център (0, 0) и радиуси 5 и 10;
			 \item x принадлежи на отсечката [0, 1];
			 \item x е равно на max \{a, b, c\};
			 \item x е различно от max \{ a, b, c\};
			 \item поне една от булевите променливи x и y има стойност true;
			 \item и двете булеви променливи x и y имат стойност true;
			 \item нито едно от числата a, b и c не е положително;
			 \item цифрата 7 влиза в записа на положителното трицифрено число p;
			 \item цифрите на трицифреното число m са различни;
			 \item поне две от цифрите на трицифреното число m са равни помежду си;
			 \item цифрите на трицифреното естествено число x образуват строго растяща или строго намаляваща редица;
			 \item десетичните записи на трицифрените естествени числа x и y са симетрични;
			 \item естественото число x, за което се знае, че е по-малко от 23, е просто.
  \end{enumerate}


\item Задача 2.12.\cite{sbornik} Да се напише програма, която проверява дали дадена година е високосна.

\end{enumerate}

\subsection {Цикли}

\begin{enumerate}[resume]


	\item Задача 1.20.\cite{sbornik} Да се напише програма, която по въведени от клавиатурата цели числа x и k ($k \geq 1$) намира и извежда на екрана k-тата цифра на х. Броенето да е отдясно наляво.

	\item Задача 2.40.\cite{sbornik} Да се напише програма, която (чрез цикъл for) намира сумата на всяко трето цяло число, започвайки от 2 и ненадминавайки n (т.е. сумата 2 + 5 + 8 + 11 + ...).

	\item Задача 2.44.\cite{sbornik} Дадено е естествено число n ($n \geq 1$). Да се напише програма, която намира броя на тези елементи от серията числа $i^3 + 13 \times i \times n + n
	^3$ , $i = 1, 2, ..., n$, които са кратни на 5 или на 9.

	\item За въведени от клавиатурата естествени числа $n$ и $k$, да се провери и изпише на екрана дали $n$ е точна степен на числото $k$.

	\textit{Упътване: Разделете променливата $n$ на променливата $k$ ``колкото пъти е възможно'' и проверете дали $n$ достига единица или някое друго число след края на процеса. Използвайте добре подбрано условие за for цикъл, оператора \% за намиране на остатък при целочислено деление, и оператора за целочислено деление /.}

\end{enumerate}


\subsection {Машини с неограничени регистри}


\small{Дефиницията на Машина с неогрничени регистри по-долу е взаимствана от учебника \cite{tprog}\textit{А. Дичев, И. Сосков, ``Теория на програмите'', Издателство на СУ, София, 1998}.

\vspace{20px}

\begin{mdframed}[hidealllines=true,backgroundcolor=gray!20]

	``Машина с неограничени регистри'' (или МНР) наричаме абстрактна машина, разполагаща с неограничена памет. Паметта на машината се представя с безкрайна редица от естествени числа $m[0],m[1],...$, където $m[i] \in \mathcal{N}$. Елементите $m[i]$ на редицата наричаме ``клетки'' на паметта на машината, а числото $i$ наричаме ``адрес'' на клетката $m[i]$.

	 МНР разполага с набор от инструцкии за работа с паметта. Всяка инструкция получава един или повече параметри (операнди) и може да предизвика промяна в стойността на някоя от клетките на паметта. Инструкциите на МНР за работа с паметта са:

	\begin{enumerate}[label=\arabic*)]
		\item \code{ZERO n}: Записва стойността 0 в клетката с адрес $n$
		\item \code{INC n}: Увеличава с единица стойността, записана в клетката с адрес $n$
		\item \code{MOVE x y}: Присвоява на клетката с адрес $y$ стойността на клетката с адрес $x$
	\end{enumerate}

	``Програма'' за МНР наричаме всяка последователност от инструкции на МНР и съответните им операнди. Всяка инструкция от програмата индексираме с поредния ѝ номер. Изпълнението на програмата започва от първата инструкция и преминава през всички инструкции последователно, освен в някои случаи, опиани по-долу. Изпълнението на програмата се прекратвя след изпълнението на последната ѝ инструкция. Например, след изпълнението на следната програма:

	\begin{verbatim}
	0: ZERO 0
	1: ZERO 1
	2: ZERO 2
	3: INC 1
	4: INC 2
	5: INC 2
	\end{verbatim}

	Първите три клетки на машината ще имат стойност 0, 1, 2, независимо от началните им стойности.

	Освен инструкциите за работа с паметта, МНР притежават и една инструкция за промяна на последователноста на изпълнение на програмата:

	\begin{enumerate}[label=\arabic*)]
	\setcounter{enumi}{3}
		\item \code{JUMP x}: Изпълнението на програмата ``прескача'' и продължава от инструкцията с пореден номер $x$. Ако програмата има по-малко от $x+1$ инструкции, изпълнението ѝ се прекратява
		\item \code{JUMP x y z}: Ако съдържанията на клетките  $x$ и $y$ съвпадат, изпълнението на програмата ``прескача'' и продължава от инструкцията с пореден номер $z$. В противен случай, програмата продължава със следващата инструкция. Ако програмата има по-малко от $z+1$ инструкции, изпълнението ѝ се прекратява
	\end{enumerate}

	Например, нека изпълнето на следната програма започва при стойности на клиетките на паметта 10,0,0,...:

	\begin{verbatim}
	0: JUMP 0 1 5
	1: INC 1
	2: INC 2
	3: INC 2
	4: JUMP 0
	\end{verbatim}

	След приключване на програмата, първите три клетки на машината ще имат стойности 10, 10, 20.

\end{mdframed}

\begin{enumerate}[resume]
	\item Нека паметта на МНР е инициалирана с редицата $m,n,0,0,...$. Да се напише програма на МНР, след изпълнението на която клетката с адрес 2 съдържа числото $m+n$.
	\item Нека паметта на МНР е инициалирана с редицата $m,n,0,0,...$. Да се напише програма на МНР, след изпълнението на която клетката с адрес 2 съдържа числото $m \times n$.
	\item Нека паметта на МНР е инициалирана с редицата $m,n,0,0,...$. Да се напише програма на МНР, след изпълнението на която клетката с адрес 2 съдържа числото 1 тогава и само тогава, когато $m>n$ и числото 0 във всички останали случаи.
\end{enumerate}

\begin{mdframed}[hidealllines=true,backgroundcolor=gray!20]
\textbf{Упътване:} На Фигура \ref{fig:mnr}~(a) е показана блок схема на програма, изпозлваща само операторите \code{=}, \code{==}, \code{++} и \code{if}, която намира в променливата \code{result} сумата на променливите $a_0$ и $a_1$. $a_0$ и $a_1$ считаме за дадени. Променливата \code{count} се иницилиаира с 0, а \code{result} - с $a_0$. В цикъл се добавя по една единица към \code {count} и \code{result} дотогава, докато \code{count} достигне стойността на $a_1$. По този начин, към \code{result} се добавят $a_1$ на брой единици, т.е. стойността ѝ се увеличава с $a_1$ спрямо налчалната ѝ стойност $a_0$.

На Фигура \ref{fig:mnr}~(b) е показана същата програма, като операторите от първата са заменени със сътответните им инструцкии на МНР. Резултатът от програмата се получава в клетката $m[2]$, а за брояч се ползва клетката $m[3]$. На блок схемата са дадени поредните номера на инструкциите в окончателната програмата на МНР:
\begin{verbatim}
0:MOVE 0 2
1:ZERO 3
2:JUMP 1 3 6
3:INC 2
4:INC 3
5:JUMP 3
\end{verbatim}
\end{mdframed}

\begin{figure}
\relscale{0.7}
  \begin{tabular}{p{7cm} p{7cm}}
      \begin{tikzpicture}[auto, node distance=1.5cm,>=latex']
      \node [entry, name=start](start){};
      \node [block,name=init, below of = start] (init)
         {\code{result:=$a_0$}\\\code{counter:=0}};
      \node [fork,name=test1fork,below of = init,node distance = 1cm]{};
      \node [condition,name=test1, below of = test1fork,node distance = 2cm] (test1) {\code{counter==$a_1$}};
      \node [block,name=inc,right of = test1, node distance = 3cm] (inc) {\code{$a_0$++}\\\code{counter++}};
      \node [entry, name=end, below of = test1, node distance = 2.5cm](end){};
      \draw [->] (start) -- (init);
      \draw [-] (init) -- (test1fork);
      \draw [->] (test1fork) -- (test1);
      \draw [->] (test1) -- node{no} (inc);
      \draw [->] (inc) |- (test1fork);
      \draw [->] (test1) -- node []{yes}(end);
      \end{tikzpicture}

      &

      \begin{tikzpicture}[auto, node distance=1.5cm,>=latex']
      \node [entry, name=start](start){};
      \node [block,name=init, below of = start, align = left] (init)
         {\code{0:MOVE 0 2}\\\code{1:ZERO 3}};
      \node [fork,name=test1fork,below of = init,node distance = 1cm]{};
      \node [condition,name=test1, below of = test1fork,node distance = 2cm] (test1) {\code{2:JUMP 1 3 6}};
      \node [block,name=inc,right of = test1, node distance = 3cm,align = left] (inc) {\code{3:INC 2}\\\code{4:INC 3}\\\code{5:JUMP 3}};
      \node [entry, name=end, below of = test1, node distance = 2.5cm](end){};
      \draw [->] (start) -- (init);
      \draw [-] (init) -- (test1fork);
      \draw [->] (test1fork) -- (test1);
      \draw [->] (test1) -- node{} (inc);
      \draw [->] (inc) |- (test1fork);
      \draw [->] (test1) -- node []{}(end);
      \end{tikzpicture}

      \\
      (a)Програма за сумиране на числата $a_0$ и $a_1$ с изпозлване само на операторите \code{=}, \code{==}, \code{++} и \code{if}.
      &
      (b)Програма за сумиране на клетките $m[0]$ и $m[1]$ с инструкции на МНР.
  \end{tabular}

  \caption{Блок схеми на програма за сумиране на числа}
  \label{fig:mnr}
\end{figure}




\pagebreak

\section {Типове и функции}

\subsection {Прости примери за функции}

\begin{enumerate}[]
	\item Задача 4.12.\cite{sbornik} Да се напише булева функция, която проверява дали дата, зададена в следния формат: dd.mm.yyyy е коректна дата от грегорианския календар.
	\item Задача 4.25.\cite{sbornik} Да се дефинира процедура, която получава целочислен параметър $n$ и база на бройна система $k \leq 16$. Процедурата да отпечатва на екрана представянето на числото $n$ в системата с база $k$.
	\item Задача 2.57.\cite{sbornik}	Да се напише булева функция, която проверява дали сумата от цифрите на дадено като параметър положително цяло число е кратна на 3.
	\item Задача 2.81.\cite{sbornik} Едно положително цяло число е съвършено, ако е равно на сумата от своите делители (без самото число). Например, 6 е съвършено, защото 6 = 1+2+3; числото 1 не е съвършено. Да се напише процедура, която намира и отпечатва на екрана  всички съвършени числа, ненадминаващи дадено положително цяло число в параметър n.

\end{enumerate}

\subsection {Елементарна растерна графика}

  \begin{mdframed}[hidealllines=true,backgroundcolor=gray!20]

  Следните задачи да се решат с показаните на лекции графични примитиви, базирани на платформата за компютърни игри SDL2. За целта е необходимо да инсталирате SDL2 на компютъра си и да настроите средата си за програмиране така, че да свърже SLD2 с вашия проект. Информация за това можете да намерите на сайта на платформата.
	Задачите можете да решите с помощта на всяка друга билиотека, поддържаща примитивите за рисуване на точки и отсечки.

  Примерната програма от лекции използва файла \code{mygraphics.h}, който можете да намерите в \href{https://github.com/stranxter/lecture-notes/tree/master/samples/01_programming%20101/2018/pixels}{\underline{хранилището на курса}}:
  \begin{mdframed}[hidealllines=true,backgroundcolor=lightgray!20]
  \relscale{0.8}
  \begin{verbatim}
  #include "mygraphics.h"
  \end{verbatim}
  \end{mdframed}

  \code{Mygraphics} ``обвива'' библиотеката SLD2 и дефинира следните лесни за използване макроси:

  \begin{itemize}
    \item \code{setColor (r,g,b)}: Дефинира цвят на рисуване с компоненти $r,g,b\in[0,255]$. Например, белият цвят се задава с $(255,255,255)$, червеният с $(255,0,0)$ и т.н.
    \item \code{drawPixel(x,y)}: Поставя една точка на екранни коррдинати $(x,y)$.
    \item \code{drawLine (x1,y1,x2,y2)}: Рисува отсечка, свързваща точките с екранни координати $(x_1,y_1)$ и $(x_2,y_2)$.
    \item \code{updateGraphics()}: Извиква се веднъж в края на програмата, за да се изобрази нарисуваното с горните примитиви.
  \end{itemize}
\end{mdframed}

\begin{figure}
  \begin{center}
  \relscale{0.7}
  \begin{tabular}{|p{5.2cm}p{5.2cm}|}
   \hline
   \vspace{10pt}
   \includegraphics[width=3cm]{images/graph_sine} &
   \vspace{10pt}
   \includegraphics[width=3cm]{images/graph_sine_coarse}\\
   (a)Графика на $y=sin(x)$, нарисувана с 300 отсечки&
   (b)Графика на $y=sin(x)$ с 10 отсечки. Нарисувани са също отсечки между точките от графиката на функцията и абсцисата\\%\hline
   \vspace{10pt}
   \includegraphics[width=3cm]{images/graph_4_polygons}  &
   \vspace{10pt}
   \includegraphics[width=3cm]{images/graph_16_polygons}  \\
   (c)Четири многоъгълника, нарисувани един върху друг с нарастващ радиус
   \vspace{10pt}&
   (d)Шестнадесет многоъгълника, нарисувани един върху друг с нарастващ радиус
   \vspace{10pt}  \\%\hline
   \vspace{10pt}
   \includegraphics[width=3cm]{images/graph_twentygon}   &
    \\
    (e)Многоъгълник с 20 върха, приближаващ окръжност
   \vspace{10pt} &
   \\\hline
  \end{tabular}
  \end{center}

  \caption{Примерни резултати от решенията на някои задачи}
  \label{fig:drawings}
\end{figure}



\begin{enumerate}[resume]


	\item По дадени екранни координати $(x,y)$ на горния ляв ъгъл на квадрат, дължина на страната $a$ на квадрата и число $n$:

	\begin{itemize}
		\item Да се нарисува квадратна матрица от $n \times $n квадрата със страна $a/n$, изпълваща дадения квдрат.
		\item Квадратите от горното условие да се заменят с тригъгълниците, образувани от пресичането на диагоналите им.
	\end{itemize}

	\item Да се нарисуват програмно следните фигури:

	\begin{itemize}
		\item Равностранен триъгълник
		\item Равностранен шестоъгълник
		\item Равностранен многоъгълник по дадени координати на пресечната точка на симетралите му (център), брой страни $n$ и разстояние от центъра до върховете $r$. При какви стойности на $n$ фигурата наподобява окръжност?
		\item Логаритмична крива
		\item Елипса с център дадени $(x,y)$ и радиуси дадени $r_1$ и $r_2$
	\end{itemize}

  \begin{mdframed}[hidealllines=true,backgroundcolor=gray!20]
    \textbf {Упътване към задачата за чертане на графика на функцията $y=sin(x)$:} Рисуват се отсечки между последователни точки от графиката на функцията, като всяка следваща точка се получава като увеличаваме стойността на аргумента $x$ с числото \code{stepX}. Тъй като $sin(x)\in[-1,1]$, ако директно визуализираме точките на получените по този начин координати $(x,sin(x))$, те ще са ``сгъстени'' около правата $y=0$ и резултатът няма да е добър. Поради това, координатите на получените  точки от кривата се умножават по \code{scaleX} и \code{scaleY} съответно, $(x.scaleX,sin(x).scaleY)$, за да се ``разпъне'' графиката по двете оси. (Вж. Фигура \ref{fig:drawings})\\

    \begin{mdframed}[hidealllines=true,backgroundcolor=lightgray!20]
    \relscale{0.8}
    \begin{verbatim}
    const double //scaleX: коефициент на скалиране по X
                 scaleX = 40.0,
                 //y0: ордината на началната точка
                 y0 = 100,
                 //scaleY: коефициент на скалиране по Y
                 scaleY = 50.0,
                 //stepX: стъпка за нарастване на аргумента
                 stepX = 0.05;
                 //nsegments: брой сегменти от кривата
    const int nsegments = 300;

    for (int i = 0; i < nsegments; i++)
    {
         double x     = scaleX*i*stepX,
                xnext = scaleX*(i+1)*stepX,
                y     = y0+scaleY*sin(stepX*i),
                ynext = y0+scaleY*sin(stepX*(i+1));
         drawLine (x,y,xnext,ynext);
    }
    \end{verbatim}
    \end{mdframed}

    \end{mdframed}

    \begin{mdframed}[hidealllines=true,backgroundcolor=gray!20]

    \textbf {Упътване към задачата за чертане на многоъгълник:} Върховете на мнгоъгълника получаваме, като започнем с точката с координати $(x+radius,y)$ и получаваме всяка следваща точка като ``завъртим'' предишната около $(x,y)$ с $2\pi/n$ радиана, където $n$ е броят на върховете на многоъгълника. Получените по този начин точки се съединияват с отсечки. (Вж. Фигура \ref{fig:drawings} и Фигура \ref{fig:pentagon}.)\\

    \begin{mdframed}[hidealllines=true,backgroundcolor=lightgray!20]
    \relscale{0.8}
    \begin{verbatim}
    /*
    Функция polygon (n,x,y,radius): Рисуване на многоъгълник
    параметър n: брой върхове на многоъгълника
    параметри x,y: координати на центъра на многоъгълника
    параметър radius: разстояние от центъра до върховете
    */
    void polygon (int n, double x, double y, double radius)
    {
      for (int side = 0; side < n; side++)
      {
         drawLine (radius*cos(side*2.0*M_PI/n)+x,
                   radius*sin(side*2.0*M_PI/n)+y,
                   radius*cos((side+1)*2.0*M_PI/n)+x,
                   radius*sin((side+1)*2.0*M_PI/n)+y);
      }
    }
    \end{verbatim}
    \end{mdframed}

    \end{mdframed}

    \begin{figure}
    \centering
    \relscale{0.7}

        \begin{tikzpicture}[auto,>=latex']
        \node [fork, name=center, fill = red] (center) at(4,4){};
        \node [below of = center,node distance = 0.5cm] {\small{$(x_0,y_0)$}};
        %(cos 0, sin 0)
        \node [fork, name=v0] (v0) at(7,4) {};
        \node [right of = v0, node distance=2.5cm] {\small{$(x_0+r.cos(0),y_0+r.sin(0))$}};
        %cos 2Pi/5, sin 2pi/5
        \node [fork, name=v1] (v1) at(4.927,6.853) {};
        \node [above of = v1,node distance = 0.5cm] {\small{$(x_0+r.cos(\frac{2\pi}{5}),y_0+r.sin(\frac{2\pi}{5}))$}};
        %cos 2*2Pi/5, sin 2*2pi/5
        \node [fork, name=v2] (v2) at(1.573,5.763) {};
        %cos 3*2Pi/5, sin 3*2pi/5
        \node [fork, name=v3] (v3) at(1.573,2.237) {};
        %cos 4*2Pi/5, sin 4*2pi/5
        \node [fork, name=v4] (v4) at(4.927,1.147) {};


        %\draw [->] (test1) -- node []{yes}(end);
        \draw [-] (v0)--(v1);
        \draw [-] (v1)--(v2);
        \draw [-] (v2)--(v3);
        \draw [-] (v3)--(v4);
        \draw [-] (v4)--(v0);
        \draw[densely dashed] (center) -- (v0);
        \draw[densely dashed] (center) -- (v1);
        \draw (4.5,4) arc (0:72:0.5);
        \node [] at (4.7,4.5) {\small{$\frac{2\pi}{5}$}};
        \draw[help lines, densely dotted] (0,0) grid (12,8);
        \draw [->, dashed,semithick](v1) arc (72:432:3);
        \end{tikzpicture}

      \caption{Рисуване на петоъгълник чрез намиране на 5 равноотдалечени точки по окръжността с радиус $r$ и център $(x_0,y_0)$}
      \label{fig:pentagon}
    \end{figure}




	\item Да се нарисува програмно котката Pusheen на Фигура~\ref{fig:pusheen} (вж. \cite{pusheen}).

  \begin{figure}
  \centering
	\includegraphics[width=10cm]{images/pusheen}
  \caption {Pusheen the cat. Фигурата е от \cite{pusheen}}
  \label{fig:pusheen}
  \end{figure}


  \item(*) \textit{Следната задача илюстрира метода на трапеците (Trapezoidal rule) за приближено изчисление на определени интеграли:}

	Да се нарисуват програмно координатни оси на евклидова коорднинатна система с даден център в екранните координати (x,y). Да приемем, че в програмата е дефинирана функция \code {double f (double x)}, за която знаем, че е дефинирана за всяка стойност на $x$.

	\begin{itemize}
		\item Да се изобрази графиката на фукцията спрямо нарисувана координатна система
		\item Да се приближи чрез трапеци с дадена дължина на основата $\delta$ фигурата, заключена между видимата графика на фигурата и абсцисата
		\item Да се визуализират така получените трапеци
		\item Да се изчисли сумата от лицата на така получените трапеци
		\item Да се експериментра с различни дефиниции на функцията $f$
	\end{itemize}


\end{enumerate}


\section {Цикли, масиви и низове}

\subsection {Цикли \textrm{II}}

Където не е посочено изрично, под ``редица от числа $a_0, a_1, ..., a_{n-1}$'' по-долу се разбира последователност от $n$ числа, въведени от стандартния вход. Задачите да се решат \emph{без} използването на масиви.


\begin{enumerate}[]


		\item Задача 3.1. \cite{sbornik} Да се напише програма, която въвежда редица от n цели числа $(1 \leq n \leq 50)$ и намира и извежда минималното от тях.

		\item Задача 3.2. \cite{sbornik} Да се напише програма, която въвежда редицата от n $(1 \leq n \leq 50)$ цели числа $a_0, a_1, ..., a_{n-1}$ и намира и извежда сумата на тези елементи на редицата, които се явяват удвоени нечетни числа.

		\item Задача 3.3. \cite{sbornik} Да се напише програма, която намира и извежда сумата от положителните и произведението на отрицателните елементи на редицата от реални числа $a_0, a_1, ..., a_{n-1}$ $(1 \leq n \leq 20)$.

		\item Задача 3.7. \cite{sbornik} Да се напише програма, която изяснява има ли в редицата от цели числа $a_0, a_1, ..., a_{n-1}$ $(1 \leq n \leq 100)$ поне два последователни елемента с равни стойности.

		\item Задача 3.8. \cite{sbornik} Да се напише програма, която проверява дали редицата от реални числа $a_0, a_1, ..., a_{n-1}$ $(1 \leq n \leq 100)$ е монотонно растяща.

    \item Задача 3.15. \cite{sbornik} Да се напише програма, която въвежда реланите вектори $a_0, a_1, ..., a_{n-1}$ и $b_0, b_1, ..., b_{n-1}$ $(1 \leq n \leq 100)$,  намира скаларното им произведение  и го извежда на екрана.

		\item Задача 3.10. \cite{sbornik} Да се напише програма, която за дадена числова редица $a_0, a_1, ..., a_{n-1}$ $(1 \leq n \leq 100)$ намира дължината на най-дългата ú ненамаляваща подредица $a_i, a_{i+1}, ..., a_{i+k}$ $(a_i \leq a_{i+1} \leq ... \leq a_{i+k})$.


\end{enumerate}

\subsection {Цикли и низове}
Където не е посочено изрично, под ``редица от символи $s_0, s_1, ..., s_{n-1}$ $(1 \leq n \leq 100)$ $a_0, a_1, ..., a_{n-1}$'' по-долу се разбира символен низ с дължина $n$, въведен от клавиатурата в масив от тип \code{char[255]}.

\begin{enumerate}[resume]


  \item Задача 3.11. \cite{sbornik}	Дадена е редицата от символи $s_0, s_1, ..., s_{n-1}$ $(1 \leq n \leq 100)$. Да се напише програма, която извежда отначало всички символи, които са цифри, след това всички символи, които са малки латински букви и накрая всички останали символи от редицата, запазвайки реда им в редицата.

	\item Задача 3.13. \cite{sbornik} Задача 3.13. Да се напише програма, която определя дали редицата от символи $s_0, s_1, ..., s_{n-1}$ $(1 \leq n \leq 100)$ е симетрична, т.е. четена отляво надясно и отдясно наляво е една и съща.

  \item Да се напише функция, която по два низа намира дължината на най-дългия им общ префикс. \textit{Префикс на низ наричаме подниз със същото начало като дадения. Пример: празният низ и низовете ``a'', ``ab'', и ``abc'' са всички възможни префикси на низа ``abc''. Дължината на най-дългия общ префикс на низовете ``abcde'' и ``abcuwz'' е 3.}

  \item Да се напише функция, която в даден низ замества всички малки латински букви със съответните им големи латински букви.

  \item Да се напише функция \code{reverse(s)}, която превръща даден низ в огледалния му образ. \textit{Например, низът ``abc'' ще се пребразува до ``cba''.}

  \item Да се напише функция, която по даден низ $s$, всички букви в който са латински, извъшва следната манипулация над него: Ако $s$ съдържа повече малки, отколкото големи букви, замества всички големи букви в $s$ с малки. В останалите случаи, всички малки букви се заместват с големи.

	\item Задача 3.26. "Хистограма на символите" \cite{sbornik} Символен низ е съставен единствено от малки латински букви. Да се напише програма, която намира и извежда на екрана броя на срещанията на всяка от буквите на низа.

  \item Да се напише булева функция, която по дадени низове $s_1$ и $s_2$ проверява дали $s_2$ е подниз на $s_1$ (\textit{Например, низът ``uv'' е подниз на низовете ``abuvc'', ``uvz'', ``zuv'' и ``uv'', но не е подниз на низа ``uwv''}.). Функцията да \emph{не} използва вложени цикли.

  \item Задача 3.28. "Търсене на функция" \cite{sbornik} Дадени са два символни низа с еднаква дължина $s_1$ и $s_2$, съставени от малки латински букви. Да се напише програма, която проверява дали съществува функция $f:char \rightarrow char$, изобразяваща $s_1$ в $s_2$, така че $f(s_1[i])$ = $f(s_2[i])$ и $i=1..$дължината на $s_1$ и $s_2$. \textit{Упътване: За да е възможна такава функция, не трябва в $s_1$ да има сивмол, на който съответстват два или повече различни символи в $s_2$. Например, низът ``aba'' може да бъде изобразен в низа ``zwz``, но не и в низа ``zwu''.}

\end{enumerate}


\pagebreak

\begin{thebibliography}{99}

\bibitem{sbornik}	Магдалина Тодорова, Петър Армянов, Дафина Петкова, Калин Георгиев, ``Сборник от задачи по програмиране на C++. Първа част. Увод в програмирането''
\bibitem{tprog} А. Дичев, И. Сосков, ``Теория на програмите'', Издателство на СУ, София, 1998
\bibitem{pusheen} Wikihow, How to Draw Pusheen the Cat, https://www.wikihow.com/Draw-Pusheen-the-Cat

\end{thebibliography}

\end{document}
