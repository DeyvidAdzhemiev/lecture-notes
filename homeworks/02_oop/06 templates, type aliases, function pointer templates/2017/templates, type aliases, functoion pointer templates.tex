\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{url}
\usepackage[bulgarian]{babel}
\usepackage{listings}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage[framemethod=tikz]{mdframed}
\usepackage{relsize}



\newcommand{\code}[1]{\texttt{#1}}

\lstset{breaklines=true}


\author{\textit{email: kalin@fmi.uni-sofia.bg}}
\title{\textsc{Задачи за задължителна самоподготовка} \\
по \\
Обектно-ориентирано програмиране\\
\textit{Предефиниране на типове, функции от високо ниво, шаблони на указатели към функции. MapReduce}}



\begin{document}
\maketitle


\begin{enumerate}

\item Инсталирайте програмата \href{http://meldmerge.org/}{\texttt{meld}} и сравнете версиите на файловете от примера за йерархията от фигури от миналата седмица и от тази седмица. Разучете как чрез \texttt{git} да получите достъп и до двете версии на файловете.

\item Като се използва шаблона \texttt{std::vector} да се създаде вектор \texttt{M} от 3 елемента, чиито елементи са вектори от по 3 числа от тип \texttt{double} (Матрица $M_{3x3}$ с елементи от тип \texttt{double}). Да се въведат елементите на \texttt{M} от клавиатурата.

\item Да се добави нов оператор \texttt{<{}<} за изход в поток на \texttt{std::vector} така, че при печатане на масива от масиви (матрицата) \texttt{M} от предишната задача, елементите да се отпечатат като правоъгълна таблица - т.е. три реда, като на всеки ред има по три числа, разделени с интервали. Операторът да е универсален и да може да се ползва за всякакви двумерни матрици, построени чрез \texttt{std::vector} с елементи от всякакви (``разумни'') типове.

\item По подобие на функцията \texttt{map} за масиви, обсъдена на лекции, да се дефинира функция \texttt{map} за \texttt{std::vector} с елементи от тип \texttt{T}. Да се подготвят подходящи помощни функции така, че чрез приложение на функцията \texttt{map} всички елементи на матрицата \texttt{M} да се увеличат с единица. \\

Да се напише подходящ тест.

\item Да се създаде \texttt{std::vector} от числа. Да се подготви подходяща помощна функция така, че чрез приложение на метода \texttt{map} всички елементи на масива да се отпечатат на екрана.

\item Нека е дадена следната структура \texttt{struct S \{int a; int b; int c;\}}. Да се дефинира и попълни примерен вектор \texttt{A} с елементи от тип \texttt{S}.

\begin{enumerate}
	\item Чрез подходяща помощна функция и използване на \texttt{map}, да се отпечата сумата на полетата \texttt{a}, \texttt{b} и \texttt{c} на всеки от елементите на \texttt{A}. Да се напише подходящ тест.
	\item Чрез подходяща помощна функция и използване на \texttt{map}, да се въведат нови стойности на висчки полета на елементите на \texttt{A} от клавиатурата.
	\item Чрез подходяща помощна функция и използване на \texttt{map}, да се увеличат с единица всички полета \texttt{a} на елементите на \texttt{A}. Да се напише подходящ тест.
	\item Чрез подходяща помощна функция и използване на \texttt{map}, да се разменят стойностите на \emph{полетата} \texttt{a} и \texttt{b} на всеки от елементите на \texttt{A}. Да се напише подходящ тест.


\end{enumerate}

\item По подобие на функцията \texttt{reduce} за масиви, обсъдена на лекции, да се дефинира функция \texttt{reduce} за \texttt{std::vector} с елементи от тип \texttt{T}. Чрез тазси функция и с подходящи помощни функции:

	\begin{enumerate}
		\item Да се намери броя на главните букви в масив от символи.
		\item По масив от точки в равнината (\texttt{struct Point \{double x,y;\};}) да се определи колко от тях са в първи квадрант.
		\item По масив от точки в равнината (\texttt{struct Point \{double x,y;\};}) да се определи дали всички точки лежат на правата с уравнение $5x + y + 1 = 0$.
		\item По масив от числа да се намери най-голямото от тях.
		\item По масив от указатели към низове (\texttt{char*}), да се намери конкатенацията им. (Внимавайте с паметта!).
		\begin{mdframed}[hidealllines=true,backgroundcolor=gray!20]
		\relscale{0.75}
		Упътване:\\

		Като първа стъпка осигурете получаване на конкатенацията без да се грижите за освобождаване на междинна памет. Операторът на \texttt{reduce} може да използва \texttt{strlen}, \texttt{strcpy} и \texttt{strcat} от \texttt{string.h}, като на всяка стъпка на конкатенацията се заделя необходимата памет. Проверете, че конкатенация се построява правилно.\\

		След това е нужно също заделената за междинния резултат памет да се освобождава на всяка стъпка. Внимавайте с какво инициализирате началото на цикъла. Това трябва да е памет, която може да бъде освободена безопасно.
		\end{mdframed}
		\item По масив от коефициенти на полинома $P(x)=a_0x^n + a_1x^{n-1} + ...+ a_n$, където $a_i$ е $i$-тия елемент на масива, да се изчисли стойността на полинома в точката $x=2$.
		\begin{itemize}
			\item Опитайте с помощта на \textit{lambda} функции да изчислите стойността на полинома в няколко различни точки.
		\end{itemize}

	\end{enumerate}

	Да се напишат подходящ тестове за всяка от точките!!!

	\item Да се дефинира типа на едноместни числови функции \texttt{doubleFunction = double (*) (double)}. Да се създаде вектор \texttt{std::vector<doubleFunction> functions} от едноместни числови функции.

	\begin{enumerate}
		\item Векторът \texttt{functions} да се инициализира с \textit{поне} 3 различни функции.
		\begin{mdframed}[hidealllines=true,backgroundcolor=gray!20]
		\relscale{0.75}
		Например: $f(x)=x^2$, $g(x)=sin(x)$, $h(x) = 2x$\\

		Можете ли да използвате \textit{lambda} функции, за да попълните елементите на масива?
		\end{mdframed}

		\item Чрез използване на функцията \texttt{reduce}, да се намери най-голямата стойност измежду стойностите на всички функции в масива в точката \texttt{x=2}. Приемаме, че всички функции са дефинирани в тази точка.
			\begin{itemize}
				\item Опитайте с помощта на \textit{lambda} функции да изчислите максималната стойност на функциите в няколко различни точки.
			\end{itemize}
		\begin{mdframed}[hidealllines=true,backgroundcolor=gray!20]
		\relscale{0.75}
				Упътване: Ако операторът, който подавате на \texttt{reduce}  e $OP: R \times E \rightarrow R$, то типът на елементите е \texttt{doubleFunction}, а на резултата - \texttt{double}. Т.е. търсите функция:\\

				\texttt{double op (double crrResult, doubleFunction crrElem)}
		\end{mdframed}

		\item Чрез използване на функцията \texttt{reduce}, да се намери тази (една от тези) от функциите в масива, която получава най-голяма стойност в точката \texttt{x = 2} спрямо всички функции в масива.

		\begin{mdframed}[hidealllines=true,backgroundcolor=gray!20]
		\relscale{0.75}
				Упътване: Следният израз\\

				\texttt{reduce(functions,findMaxFun,functions[0])},\\

				където \texttt{fundMaxFun} е операторът за \texttt{reduce}, който трябва да дефинирате, ще даде търсеният в условието резултат - функция. Съответно, така намерената функция можем да приложим в точката \texttt{x=2} и да отпечатаме резултата:\\

				\texttt{cout << reduce(functions,findMaxFun,functions[0])(2)}\\

				Така получената стойност ще е най-голяма измежду стойностите на всички функции в масива \texttt{functions} в точката \texttt{x=2} и ще съвпада с намерената в точка (б) стойност.\\

				Можете ли да замените \texttt{findMaxFun} с \texttt{lambda} функция?



		\end{mdframed}

		Напишете подходящи тестове за всяка от точките!!!

	\end{enumerate}


\end{enumerate}


	\vspace{20px}


\end{document}
