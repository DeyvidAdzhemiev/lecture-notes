\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{url}
\usepackage[bulgarian]{babel}
\usepackage{listings}
\usepackage[framemethod=tikz]{mdframed}
\usepackage{relsize}



\lstset{breaklines=true}


\author{\textit{email: kalin@fmi.uni-sofia.bg}}
\title{\textsc{Задачи за задължителна самоподготовкa} \\
по \\
Структури от данни и програмиране}



\begin{document}
\maketitle


\begin{enumerate}

	\item Да се дефинира метод \texttt{HashMap::efficiency()}, който изчислява ефективността на хеш таблицата като отношението  $\frac{all-coliding}{all}$, където $coliding$ е броят на ключовете, записани при колизия, а $all$ е броят на всички записани ключове.


	\item Да се дефинира оператор \texttt{<}\texttt{<} за клас \texttt{HashMap}, който отпечатва в поток всички двойки ключ-стойност в Хеш таблицата.

	\item Да се напише програма, която въвежда от клавиатурата две текста с произволна големина $t_1$ и $t_2$. Програмата да извежда броя на всички срещания на думи в $t_2$, които се срещат и в $t_1$.

	Пример: за следните текстове

	\textit{In computing, a hash table (hash map) is a data structure used to implement an associative array, a structure that can map keys to values. A hash table uses a hash function to compute an index into an array of buckets or slots, from which the correct value can be found.}

	и

	\textit{Ideally, the hash function will assign each key to a unique bucket, but this situation is rarely achievable in practice (usually some keys will hash to the same bucket)}

	Този брой е 10, съставен от думите \textit {the} (2 срещания във втория текст), \textit{a} (1 срещане), \textit{hash} (2), \textit {function} (1), \textit{to} (2), \textit{is} (1), \textit{keys} (1).


	\item Да се напише програма, която въвежда от клавиатурата две текста с произволна големина $t_1$ и $t_2$. Програмата да извежда броя на уникалните думи в $t_2$, които се срещат и в $t_1$.

	Пример: за двата текста от предишната задача, този брой е 7, съставен от думите \textit {the}, \textit{a}, \textit{hash}, \textit {function}, \textit{to}, \textit{is}, \textit{keys}.


	\item Да се напише програма, която прочита от входа даден текст с произволна големина и намира такава дума с дължина повече от 3 букви, която се среща най-често в текста. Пример: за текста

	\textit{In computing, a hash table (hash map) is a data structure used to implement an associative array, a structure that can map keys to values. A hash table uses a hash function to compute an index into an array of buckets or slots, from which the correct value can be found.}

	Най-често срещаната дума е \textit{hash}.

	\item От клавиатурата да се въведе цялото положително число $n$, следвано от $2 \times n$ цели положителни числа $a_1, b_1, a_2, b_2, ..., a_n, b_n$. Програмата да печата на екрана \texttt{``Yes''}, ако изображението, дефинирано като $h(a_i)=b_i,i=1,...,n$ е добре дефинирана функция. Т.е. програмата да проверява дали има два различни индекса $i$ и $j$, за които е изпълнено $a_i=a_j$, но $b_i \neq b_j$.




		\item Да се дефинира \texttt{operator *} на шаблона на хеш-таблицата. Хеш-таблицата \texttt{c}, която се получава при \texttt{c = a * b}, да съдържа като множество от ключове сечението на множествата на ключове на \texttt{a} и \texttt{b}, като стойноста на всеки ключ е двойка (\texttt{std::pair}) от съответните стойности от \texttt{a} и \texttt{b}. Хеш-функцията на \texttt{c} да е същата като на \texttt{b}.

		\item Да се дефинира \texttt{operator +} на шаблона на хеш-таблицата. Хеш-таблицата \texttt{c}, която се получава при \texttt{c = a + b}, да съдържа като ключове симетричната разлика на ключовете на \texttt{a} и \texttt{b}, със съответните им стойности от \texttt{a} и \texttt{b}. Хеш-функцията на \texttt{c} да е същата като на \texttt{b}.

		\emph{Симетрична разлика на множествата $A$ и $B$ наричаме множеството $C = A \Delta B = A \cup B - A \cap B$, съдържащо тези елементи на $A$, които не са елементи на $B$ и тези елементи на $B$, които не са елементи на $A$.}

		\item Да се дефинира метод

		\texttt{void map (void (*f) (ValueType\&))}

		на хеш-таблицата, който прилага функцията \texttt{f} над всички стойности в хеш-таблицата.

		\item Да се дефинира метод

		\texttt{void mapKeys (KeyType (*f) (const KeyType\&))}

		на хеш-таблицата, който замества всеки ключ \texttt{key} на хеш-таблицата с \texttt{f(key)}, като се запазва старата му стойност.

		\emph{Упътване: Да се извърши съответното ре-хеширане на елемента и той да се премести на съответния нов индекс в таблицата.}


		\item Да се дефинира \texttt{operator *} на шаблона на хеш-таблицата. Хеш-таблицата \texttt{c}, която се получава при \texttt{c = a * b}, да съдържа като множество от ключове сечението на множествата на ключове на \texttt{a} и \texttt{b}, като стойноста на всеки ключ е:

		\begin{itemize}
			\item Вектор с два елемента -- стойността на ключа от \texttt{a} и стойността на ключа от \texttt{b}, ако тези стойности \emph{не са вектори}.
			\item Конкатенацията на стойността на ключа от \texttt{a} и стойността на ключа от \texttt{b}, ако тези стойности \emph{\underline{са} вектори}.
		\end{itemize}

		Хеш-функцията на \texttt{c} да е като хеш-функцията на \texttt{b}.
		\\
		\\

		\begin{mdframed}[hidealllines=true,backgroundcolor=gray!20]
		\relscale{0.75}
		Пример: Операторът да удовлетворява следния тест:

	\begin{lstlisting}
	HashMap<string,double> m(5,stringhash1);
	m["Kalin"] = 1.85; m["Ivan"] = 1.86;
	HashMap<string,double> m1(3,stringhash1);
	m1["Kalin"] = 2; m1["Petar"] = 2;
	HashMap<string,vector<double>> mult = m * m1;
	mult = mult * mult;

	assert (mult.containsKey("Kalin"));
	assert (!mult.containsKey("Ivan"));
	assert (!mult.containsKey("Petar"));
	assert (mult["Kalin"].size() == 4);
	\end{lstlisting}

		\end{mdframed}

		\begin{mdframed}[hidealllines=true,backgroundcolor=gray!20]
		\relscale{0.75}
		Решение.

		Можем да реализираме глобален шаблон на оператор за умножение на хеш-таблици:

	\begin{verbatim}
	template <class KeyType, class ValueType>
	HashMap<KeyType,vector<ValueType>>
	  operator * (const HashMap<KeyType,ValueType> &hm1,
	              const HashMap<KeyType,ValueType> &hm2)

	\end{verbatim}

		Както се вижда, аргументите на оператора са две хеш-таблици с тип на стойностите \texttt{ValueType}, а стойността на оператора е от типа \texttt{vector<ValueType>}. Един лесен начин да реализираме тялото на оператора е:
		\\


	\begin{verbatim}
	HashMap<KeyType,vector<ValueType>>
	  result(hm2.size(),hm2.getHashFunction());
	for (const KeyType &key : hm1)
	{
	    //key е в сечението на ключовете
	    if (hm2.containsKey (key))
	    {
	        result[key].push_back(hm1[key]);
	        result[key].push_back(hm2[key]);
	    }
	}
	return result;

	\end{verbatim}

		Очевидно е, че ако типа \texttt{ValueType} се случи да е самият той \emph{вектор}, ефектът от горната реализация ще бъдат стойности, които са \emph{вектори от вектори}, а това не е търсеният резултат. Следователно нашата реализация трябва да ``знае'' кога \texttt{ValueType} е вектор и да вземе съответните мерки да конкатенира векторите, които са стойности на ключа \texttt{key} в двете таблици \texttt{hm1} и \texttt{hm2}.

		От друга страна, няма как по време на изпълнението на програмата да определим в тялото на оператора дали \texttt{ValueType} е вектор или не е. Дори да използваме някакъв \texttt{RTTI} трик и все пак да разберем в \emph{run time}, че \texttt{ValueType} е вектор, ще се наложи да приложим още трикове, с които да преобразуваме \texttt{ValueType} така, че да можем да използваме методите на \texttt{std::vector} за достъп до елементите и да извършим конкатенацията. Би се получило неелегантно и неразбираемо решение.

		За щастие, шаблоните в \texttt{C++} ни позволяват да направим частен случай на шаблона на оператора \texttt{*}, който да се предпочете от компилатора тогава, когато хеш-таблицата е със стойност вектори. Необходимо е единствено да добавим още един шаблон:

	\begin{verbatim}
	template <class KeyType, class ValueType>
	HashMap<KeyType,vector<ValueType>>
	  operator * (const HashMap<KeyType,vector<ValueType>> &hm1,
	              const HashMap<KeyType,vector<ValueType>> &hm2)
	\end{verbatim}


		Забележете, че хеш-таблиците са дефинирани с тип на стойностите \texttt{vector<ValueType>}, което е частен случай на простото \texttt{ValueType} в предишния оператор \texttt{*}, но е достатъчно на компилатора да подбере именно този оператор при опит да умножим две хеш-таблици, чиито стойности са от тип вектор. Съответната реализация на оператора е:
		\\
		\\

	\begin{verbatim}
	HashMap<KeyType,vector<ValueType>>
	  result(hm2.size(),hm2.getHashFunction());
	for (const KeyType &key : hm1)
	{
	    //key е в сечението на ключовете
	    if (hm2.containsKey (key))
	    {
	        result[key] = append (hm1[key], hm2[key]);
	    }
	}
	return result;

	\end{verbatim}

	    Тук \texttt{append} е помощна функция за конкатенация на вектори.




		\end{mdframed}




	\end{enumerate}






\end{document}
