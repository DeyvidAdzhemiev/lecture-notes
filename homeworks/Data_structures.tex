\clearpage\section {Линеен едносвързан и двусвързан списък}

\subsection {Представяне на двусвързан списък}

\begin{mdframed}[hidealllines=true,backgroundcolor=gray!20]
Възел на линеен двусвързан списък представяме със следния шаблон на структура:
\begin{verbatim}
template <class T>
struct dllnode
{
  T data;
  dllnode<T> *next, *previous;
};
\end{verbatim}
Освен ако не е указано друго, задачите по-долу да се решат като се реализират методи на клас \code{DLList} със следния скелет:
\begin{verbatim}
template <class T>
class DLList
{
  //...
  private:
  dllnode<T> *first, *last;
};
\end{verbatim}
Преди да пристъпите към задачите, реализирайте подходящи контруктори, деструктор и оператор за присвояване на класа.
\end{mdframed}

\begin{figure}
    \centering
  
      \begin{tikzpicture}[auto, node distance=2cm,>=latex']
      \node[lnode] (n1) {\nodepart{two}1};
      \node[lnode, right of = n1] (n2) {\nodepart{two}2};
      \node[lnode, right of = n2] (n3) {\nodepart{two}3};
      \node[lnode, right of = n3] (n4) {\nodepart{two}4};
      \node[lnode, right of = n4] (n5) {\nodepart{two}5};
  
      \node[rectangle,left of = n1](start){};
  
      \draw[*->]  (start)-- (n1);
  
      \draw[*->] let \p1 = (n2.three), \p2 = (n1.center) in (\x1,\y2) -- (n3);
      \draw[*->] let \p1 = (n1.three), \p2 = (n1.center) in (\x1,\y2) -- (n2);
      \draw[*->] let \p1 = (n3.three), \p2 = (n1.center) in (\x1,\y2) -- (n4);
      \draw[*->] let \p1 = (n4.three), \p2 = (n1.center) in (\x1,\y2) -- (n5);
      \draw[*->,dashed] let \p1 = (n2.one), \p2 = (n1.center) in ([shift={(0.1cm,-0.1cm)}]\x1,\y2) |-([shift={(0,0.5cm)}]n2.north west) -- ([shift={(0,0.5cm)}]n1.north) -| ([shift={(-1cm,0cm)}]n1);
      \draw[*->,dashed] let \p1 = (n3.one), \p2 = (n2.center) in ([shift={(0.1cm,0.1cm)}]\x1,\y2) |-([shift={(0,-1cm)}]n3.north west) -- ([shift={(0,-1cm)}]n2.north) -| ([shift={(-1cm,0cm)}]n2);
      \draw[*->,dashed] let \p1 = (n4.one), \p2 = (n3.center) in ([shift={(0.1cm,-0.1cm)}]\x1,\y2) |-([shift={(0,0.5cm)}]n4.north west) -- ([shift={(0,0.5cm)}]n3.north) -| ([shift={(-1cm,0cm)}]n3);
      \draw[*->,dashed] let \p1 = (n5.one), \p2 = (n4.center) in ([shift={(0.1cm,0.1cm)}]\x1,\y2) |-([shift={(0,-1cm)}]n5.north west) -- ([shift={(0,-1cm)}]n4.north) -| ([shift={(-1cm,0cm)}]n4);
      \end{tikzpicture}
    \caption{Двусвързан списък}
    \label{fig:skiplist}
  \end{figure}
  

Следните задачи да се решат като упражнение за директно боравене с възлите на линеен двусвързан списък. Функциите (методите) да се тестват с подходящи тестове.

\begin{enumerate}

	\item  Да се дефинира функция \code{int count(dllnode<T>* l,int x)}, която преброява колко пъти елементът \code{x} се среща в списъка с първи елемент \code{l}.
	\item  Фунцкция \code{dllnode<int>* range (int x, int y)} която създава и връща първия елемент на списък с елементи $x, x+1, ..., y$, при положение, че $x \leq y$.
	\item  Да се дефинира функция \code{removeAll (dllnode<T>*\& l,const T\& x)}, която изтрива всички срещания на елемента \code{x} от списъка \code{l}.
	\item  Да се дефинира функция \code{void append(dllnode*<T>\& l1, dllnode<T>* l2)}, която добавя към края на списъка $l_1$ всички елементи на списъка $l_2$. Да се реализира съответен оператор \texttt{+=} в класа на списъка.
	\item  Да се дефинира функция \code{dllnode* concat(dllnode<T>* l1, dllnode<T>* l2)}, който съединява два списъка в нов, трети списък. Т.е. \code{concat($l_1,l_2$)} създава и връща нов списък от елементите на \code{$l_1$}, следвани от елементите на \code{$l_2$}. Да се реализира съответен оператор \texttt{+} в класа на списъка.
	\item  Да се дефинира функция \code{reverse}, която обръща реда на елементите на списък. Например, списъкът с елементи $1,2,3$ ще се преобразува до списъка с елементи $3,2,1$.
	\item Да се напише функция \code{void removeduplicates (dllnode *\&l)}, която изтрива всички дублиращи се елементи от списъка $l$.
  \item За шаблона \texttt{DLList} да се реалзиира изтриване на елемент по индекс.
\end{enumerate}

\subsection {Списъци и сложности}
\label{timing}
\begin{mdframed}[hidealllines=true,backgroundcolor=gray!20]
Функцията \code{std::clock()} от \code{<ctime>} връща в абстрактни единици времето, което е изминало от началото на изпълнение на програмата. Обикновено тази единица за време, наречена ``\code{tick}'', е фиксиран интервал ``реално'' време, който зависи от хардуера на системата и конфирграцията ѝ. Константата \code{CLOCKS\_PER\_SEC} дава броя \code{tick}-ове, които се съдържат в една секунда реално време.

Чрез следния примерен код може да се измери в милисекунди времето за изпълнение на програмния блок, обозначен с ``...''.
\begin{verbatim}
clock_t start = std::clock();
//...
clock_t end = std::clock();

long milliseconds = (double)(end-start)/
                    (CLOCKS_PER_SEC/1000.0);

\end{verbatim}
\end{mdframed}

\begin{enumerate}[resume]

\item За шаблона DLList да се дефинира метод \texttt{size\_t find(const T\& x)}, който намира поредния номер на елемента \texttt{x} в списъка (или връща размера на списъка, ако такъв елемент няма). Да се напише подходящ тест и да се изследва времевата сложност на метода емпирично.

\item Да се изпробват поне две различни стратегии за разширяване на динамичен масив (например, увеличаване на размера с 1 и с коефициент). Да напишат подходящи тестове и да се сравнят производителностите на двата подхода емпирично.

\end{enumerate}


\subsection{SList (опростен вариант на Skip List)}

\begin{mdframed}[hidealllines=true,backgroundcolor=gray!20]
Разглеждаме \emph{опростена} реализация на структурата от данни Skip List (``Списък с прескачене, СП''). Възелът на линейния едносвързан списък разширяваме с още един указател към следващ елемент:

\begin{verbatim}
template <class T>
struct lnode
{
  T data;
  lnode<T> *next, *skip;
};
\end{verbatim}
Както и при стандартния едносвързан списък, всеки от елментите на СП съдържа в указателя \code{next} адреса на непосредствения си съсед. Елементите на списъка са под дадена наредба. Някои от елементите могат да съдържат в указателя \code{skip} дреса на друг елемент, намиращ се по-напред в редицата от елементи (вж. Фигура \ref{fig:skiplist}). Например, нека имаме СП с $n$ елемента в нарастващ ред. Ако списъкът е построен така, че всеки $\sqrt{n}$-ти елемент има указател към следващия  $\sqrt{n}$-ти елемент, то търсенето на подсписъка, съдържащ даден елемент, ще бъде със сложност $O(\sqrt{n})$. Търсенето в рамките на подсписъка с $\sqrt{n}$ елемента остава линейно. Идеята може да се продължи така, че всеки елемент да може да има и по-голям брой указатели към елементи все по-напред в СП, но за нашите цели ще се ограничим до описания прост СП.

Следващите задачи изискват реализация на клас \code{SList} с основните му канонични методи и метод за построяване на ``бързите връзки''. Реализирайте обиновен метод за вмъкване на елементи \code{insertSorted}, който вмъква елементи грижейки се само за непосредствените връзки (\code{next}), и метод \code{speedup}, който построява бързите връзки в списъка, след като в него са вмъкнати определен брой елементи.
\end{mdframed}

\begin{figure}
  \centering

    \begin{tikzpicture}[auto, node distance=2cm,>=latex']
    \node[lnode] (n1) {\nodepart{two}1};
    \node[lnode, right of = n1] (n2) {\nodepart{two}2};
    \node[lnode, right of = n2] (n3) {\nodepart{two}3};
    \node[lnode, right of = n3] (n4) {\nodepart{two}4};
    \node[lnode, right of = n4] (n5) {\nodepart{two}5};

    \node[rectangle,left of = n1](start){};

    \draw[*->]  (start)-- (n1);

    \draw[*->] let \p1 = (n2.three), \p2 = (n1.center) in (\x1,\y2) -- (n3);
    \draw[*->] let \p1 = (n1.three), \p2 = (n1.center) in (\x1,\y2) -- (n2);
    \draw[*->] let \p1 = (n3.three), \p2 = (n1.center) in (\x1,\y2) -- (n4);
    \draw[*->] let \p1 = (n4.three), \p2 = (n1.center) in (\x1,\y2) -- (n5);
    \draw[*->,dashed] let \p1 = (n1.one), \p2 = (n1.center) in ([shift={(0.1cm,-0.1cm)}]\x1,\y2) |-([shift={(0,0.5cm)}]n1.north east) -- ([shift={(0,0.5cm)}]n3.north) -| (n3);
    \draw[*->,dashed] let \p1 = (n3.one), \p2 = (n3.center) in ([shift={(0.1cm,0.1cm)}]\x1,\y2) |-([shift={(0,-0.5cm)}]n3.south east) -- ([shift={(0,-0.5cm)}]n5.south) -| (n5);
    \end{tikzpicture}
  \caption{Списък с прескачане}
  \label{fig:skiplist}
\end{figure}

\begin{enumerate}[resume]


  \item  Да се реализират конструктор за копиране и оператор на присвояване на \code{SList}, които репликират и бързите връзки.
  \item Да се подобри методът за вмъкване на елемент \code{insertSorted}. Ако при вмъкване на нов елемент някой подсписък (обособен от дадена бърза вързка) получи повече от $2\sqrt(n)$ елемента, да се добави нова бърза връзка така, че подсписъка да се раздели на два подсписъка.
	\item  Да се извърши времево измерване на проблема за търсене на елемент в подреден \code{SList}, както е обяснено в Секция \ref{timing}, и да се изобрази чрез графика. Да се извършат емпирични сравнения на производителността на търсенете със и без оптимизацията.

\end{enumerate}


\pagebreak

\subsection {Итератори за линейни СД}
\label{iterators1}
Следните задачи да се решат като упражнение за работа с итератори. Задачите изискват реализация на клас линеен двусвързан списък и \code{forward} итератор за него. Всяка функциия да се тества с подходящи тестове.


\begin{enumerate}[resume]

	\item Да се разшири интераторът на двусвързан списък така, че да поддържа оператора за стъпка назад \texttt{-{}-}.

	\item Да се напише функция \code{bool duplicates (...)}, която проверява дали в контейнер има дублиращи се елементи.

	\item Да се напише фунцкия \code{bool issorted (...)}, която проверява дали елементите на даден контейнер са подредени в нарастващ или в намаляващ ред.

	\item Да се напише фунцкия \code{bool palindrom (...)}, която проверява дали редицата от елементите на даден контейнер обрзува палиндром (т.е. дали се чете еднакво както отляво надясно така и отдяно наляво).

	\item Да се реализира константен итератор за двусвързани списъци и горните функции да се преработят така, че да могат да работят с константни итератори.

    

\end{enumerate}

\subsection {Функции от високо ниво и оператори над итератори}

\begin{mdframed}[hidealllines=true,backgroundcolor=gray!20]
  Нека ``поредица'' да наричаме последователни елементи на някакъв контейнер, зададени чрез итератори към началото и края на последователността. С помощта на следния шаблон:
  \begin{verbatim}
template <class Iterator>
class Sequence{
    public:
        Sequence (const Iterator &b, 
                  const Iterator &e):_begin(b), _end (e){}
        Iterator begin()
        {return _begin;}
        Iterator end()
        {return _end;}
    private:
        Iterator _begin;
        Iterator _end;
};
  \end{verbatim}

  става възможно не само да оформим двойката начало-край в общ обект, но и да итерираме съответната поредица с цикъл \code{for}. Ако \code{begin} и \code{end} са съответните итератори към елементи от тип \code{E} и имаме обекта \code{Sequence<SomeIterator>(begin,end)}, то можем да направим обхождането:
 \begin{verbatim}
for (E& x : seq){...}   
 \end{verbatim}
 
 На лекции разглеждаме деструктивен вариант на функцията от високо ниво \code{map}, извършваща еднотипна трансформация на елементите на поредица, като се абстрахира напълно от контейнера:
  
\begin{verbatim}
template <class Iterator, class Element>
void map(Sequence<Iterator> seq,
          Element (*f)(const Element &))
{
    for (Element& e: seq)
    {e = f (e);}    
}
\end{verbatim}

  Може да разгледаме и фунцкията за агрегации \code{reduce}, позната от функционалното програмиране: 
\begin{verbatim}
template <class Iterator, class Element>
Element reduce(Sequence<Iterator> seq,
                Element (*op)(const Element &, const Element &),
                Element null_val)
{
    Element accum = null_val;
    for (Element e : seq)
    { accum = op(accum, e); }
    return accum;
}
\end{verbatim}
Възможно е също да реализираме операция с поредица, която изменя броя или реда на елементите ѝ, отново без знание за подлежащия контейнер. Такава е например операцията \code{filter}. Това налага да се конструира нова поредица, като по някакъв начин се измени поведението на итераторите на оригиналната поредица. Например, реализирания на лекции \code{FilterIterator} ``изменя'' даден друг итератор като ``прескача'' елементите, които не удовлетворяват даден предикат. По този начин можем да дефинираме:
\begin{verbatim}
template <class Iterator, class Element>
Sequence<FilterIterator<Iterator,Element>> 
    filter(Sequence<Iterator> &seq,
           bool (*pred)(const Element &))
{
  FilterIterator<Iterator,Element> begin (seq.begin(),seq.end(),pred);
  FilterIterator<Iterator,Element> end (seq.end(),seq.end(),pred);

  return Sequence<FilterIterator<Iterator, Element>> (begin, end);
}    
  \end{verbatim}
  Използването на \code{Sequence} както за параметър, така и за резултат на тези функции, ни позволява да ги използваме за обхождане на новополучените подредици. Също така, можем да композираме функциите:
  \begin{verbatim}
for (E x : filter (seq, even)) {...обработка само на четните елементи на seq...}
reduce(filter(seq,even),plus,0);//сума на четните елементи на seq 
  \end{verbatim}
Ако по подобие на \code{FilterIterator} реализираме \code{MapIterator}, можем да напраивм функционален вариант на \code{map}, \code{mapf}. Това ще ни позволи на намерим сумата на четните елементи на поредица, след като ги увеличим с единица, по следния начин:
\begin{verbatim}
reduce(mapf(filter(seq,even), inc), plus, 0)  
\end{verbatim}
\end{mdframed}

\begin{enumerate}[resume]
  \item По аналогия на дадените примери да се дефинира функция \code{append(a,b)}, която създава нова поредица чрез слепване на поредиците \code{a} и \code{b}.
  \item По аналогия на дадените примери да се дефинира функция \code{combine(a,b,f)}, която създава нова поредица от стойностите на двуместната функция \code{f}, приложена върху съответните елементи на \code{a} и \code{b}. Функцията да се демомстрира като се съберат съответните елементи на две редици.
  \item По аналогия на дадените примери да се дефинира функция \code{merge(a,b)}. Ако $a=a_1,...,a_k$, $b=b_1,...,b_l$, то $merge(a,b)=a_1,b_1,a_2,b_2,...$. 
  \item По аналогия на дадените примери да се дефинира функция \code{zip(a,b)}, която създава нова поредица от двойките (\code{std::pair}) от стойностите на съответните елементи на \code{a} и \code{b}. 
\end{enumerate}


\section {Приложения на структурата от данни стек}

\subsection {Общи задачи за стекове}

\begin{enumerate}
  \item Нека е даден масив с $n$ елемента. За всеки от елементите на масива да се изведе следващия в масива по-голям елемент. Т.е. за всеки елемент $a[i]$ да се отпечата $a[j]$ такъв, че $n>j>i$ и $\forall k \in (i,j):a[k] \leq a[i]$. Ако такъв елемент няма, да се изведе числото $-1$. Пример, за масива \verb#{4, 5, 2, 25}#, да се изведат двойките \verb#(4,5), (5,25), (2,25), (25,-1)#. Алгоритъмът да работи с линейна сложност спрямо $n$. \emph{Упътване: Задачата е известна под името ``Next Greater Element(NGE)''}.
\end{enumerate}

\subsection {Изрази и стекове}

\begin{enumerate}[resume]
  \item Даден е израз, който може да съдържа отварящи и затварящи скоби.  Да се напише функция, която проверява дали скобите на израза са  правилно балансирани. Например, изразът \code{(x+(y+(1+2)))} считаме за правилно балансиран, но не и израза \code{(x+y)*3)+(x+(1+2)}.
  \item Да се реши горната задача при положение, че изразът може да има едновременно кръгли, фигурни и квадратни скоби.

\end{enumerate}


\begin{mdframed}[hidealllines=true,backgroundcolor=gray!20]
  По време лекции разглеждаме реализация на \emph{Shunting Yard} алгоритъма за пребразуване на инфиксен аритметичен израз в постфиксен вид (Обратен полски запис). Реализацията работи само с двуместни оператори и скоби, като отчита приоритет на операциите.
\end{mdframed}

\begin{enumerate}[resume]
  \item При изчисляването на стойността на постфиксен израз, да се разгледа случая на ляво-асоциативни оператори (като деление и изваждане).
  \item При изчисляването на стойността на постфиксен израз, да се позволи използването на едноместни функции без влагане. Да се поддържа ограничен набор от предефинирани функции (напр. $sin(x)$ и $\sqrt{x}$.). Функциите да са само едноместни и да не се позволява влагане на извиквания.
  \item Да се преработи алгоритъма за изчисляването на стойността на постфиксен израз така, че да се генерира прав полски запис (префиксна нотация).
\end{enumerate}

\subsection {Цикъл със стек вместо рекурсия}

\underline{Упътване}:Решете задачите с рекурсия и след това преобразувайте решението в решение със стек.


\begin{enumerate}[resume]

 \item (*)Да се дефинира функция за намиране на стойността на полинома на Ермит $Hn(x)$ (x е реална променлива, а n неотрицателна цяла променлива), дефиниран по следния начин:

 $H_0(x)=1$

 $H_1(x)=2x$

 $H_n(x)=2xH_{n-1}(x)+2(n-1)H_{n-2}(x), n>1$,

 за дадени $n$ и $x$ \underline{с използване на стек}.


 \item Нека е дадена абстрактна шахматна дъска с размери $n \times n$, $4 \le n \le 8$ и число $k$, $0 \le k \le n$. Казваме, че разположени на дъската  $k$ коня образуват ``валидна конфигурация'', ако никоя фигура не е поставена на поле, което се ``бие'' от друга фигура според съответните шахматни правила.

 Да се дефинира клас \texttt{KnightConfig}, представящ ``конфигуратор'' на шахматни коне. Конструкторът на класа инициализира конфигуратора с числата $n$ и $k$. Класът позволява ``обхождането'' една по една на всички валидни конфигурации за дадените параметри, по подобие на \texttt{forward} итератор на структура от данни. Класът да притежава следните методи:

 \begin{itemize}
   \item \texttt{void KnightConfig::printCurrentConfig()}: Отпечатва текущо намерената конфигурация.
     Пример за отпечатана конфигурация с $n=5, k=2$:
     \begin{verbatim}
     _ _ _ _ _
     _ _ H _ _
     _ _ _ _ _
     _ _ _ _ H
     _ _ _ _ _

     \end{verbatim}
   \item \texttt{void KnightConfig::findNextConfig()}: Намира следваща конфигурация.
   \item \texttt{bool KnightConfig::noMoreConfigs()}: Показва дали всички възможни конфигурации са вече изчерпани.
 \end{itemize}

 \item Да се реши задачата за Ханойските кули с използване на стек.

 Да се дефинира клас \texttt{HanoyPlayer} със следните методи:

 \begin{itemize}
   \item Конструктор с параметър, указващ броя дискове върху лявото колче за началното състояние на играта.
   \item Метод \texttt{bool final()}, който показва дали играта е достигнала финанлно състояние (т.е. всички дискове са на дясното колче).
   \item Метод \texttt{makeMove()}, който извършва един ход от играта.
   \item Метод \texttt{printBoard()}, който отпечатва текущото състояние на игровата дъска, например по следния начин:
     \begin{verbatim}

        2
        3     1
        5  *  4
     \end{verbatim}
   На примера е изобразено състояние на играта, при което на лявото колче има три диска - с размери 5, 3 и 2, на средното колче няма дискове, а на дясното има два диска - с размери 4 и 1.

 \end{itemize}

\end{enumerate}

\pagebreak

\section {Двоични дървета}

\subsection {Прости обхождания}

\begin{mdframed}[hidealllines=true,backgroundcolor=gray!20]
Възел на двоично дърво представяме със следния шаблон на структура:
\begin{verbatim}
template <class T>
struct BinTreeNode
{
  T data;
  BinTreeNode *left, *right;
  //... помощни конструктори
};
\end{verbatim}
Освен ако не е указано друго, задачите по-долу да се решат като се реализират методи на клас \code{BinTree} със следния скелет:
\begin{verbatim}
template <class T>
class BinTree
{
  //...
  private:
  BinTreeNode<T> *root;
};
\end{verbatim}
\end{mdframed}

\begin{enumerate}[]

	\item Да се деифнира метод \texttt{count} на клас \texttt{BinTree}, който намира броя на елементите на дървото.

	\item Да се деифнира метод \texttt{countEvens} на клас \texttt{BinTree}, който намира броя на елементите на дърво от числа, които са четни.


	\item Да се дефинира метод \texttt{int BTree<T>::searchCount (bool (*pred)(const T\&))} към клас \texttt{BinTree}, който намира броя на елементите на дървото, които удовлетворяват предиката \texttt{pred}.

	Да се приложи \texttt{searchCount} за решаване на горните две задачи.

	\item Да се дефинира метод \texttt{bool BinTree<T>::height ()}, намиращ височината на дърво. \textit{Височина на дърво наричаме дължината (в брой върхове) на най-дългия път от корена до кое да е листо на дървото.}
	\textit{Пример. Височината на дървото на Фигура \ref{fig:tree1} е \textbf{3}.}

  \begin{figure}
  \centering
	\includegraphics[width=4cm]{images/tree1}

	\caption{Двоично наредено дърво}
  \label{fig:tree1}
  \end{figure}


	\item Да се деифнира метод \texttt{countLeaves} на клас \texttt{BinTree}, който намира броя на листата в дървото.

	\item Да се деифнира метод \texttt{maxLeaf} на клас \texttt{BinTree}, който намира най-голямото по стойност листо на непразно дърво. Да се приеме, че за типа \texttt{T} на шаблона \texttt{BinTree} е дефиниран операторът \texttt{<}.

	\item Нека е дадено дървото \texttt{t} и низът \texttt{s}, съставен само от символите `L' и `R' ($s \in \{L,R\}^*$). Нека дефинираме ``съответен елемент'' на низа \texttt{s} в дървото \texttt{t} по следния начин:
	\begin{itemize}
		\item Ако дървото \texttt{t} е празно, низът \texttt{s} няма съответен елемент
		\item Ако низът \texttt{s} е празен, а дървото \texttt{t} - не, то коренът на дървото \texttt{t} е съответният елемент на низа \texttt{s}
		\item Ако първият символ на низа \texttt{s} е `L' и дървото \texttt{t} не е празно, то съответният елемент на низа \texttt{s} в дървото \texttt{t} е съответният елемент на низа $s+1$ в \textbf{лявото} поддърво на \texttt{t}
		\item Ако първият символ на низа \texttt{s} е `R' и дървото \texttt{t} не е празно, то съответният елемент на низа \texttt{s} в дървото \texttt{t} е съответният елемент на низа $s+1$ в \textbf{дясното} поддърво на \texttt{t}
	\end{itemize}

	\textit{Пример. За 	дървото от Фигура \ref{fig:tree1}, съответният елемент на празния низ е 10, на низа ``RL'' е 15, а ``RLR'' няма съответен елемент.}

	Да се дефинира метод \texttt{T\& BinTree<T>::getElement (const char *s)}, който намира съответния елемент на низа \texttt{s}. Какво връща методът в случаите на липса на съответен елемент е без значение.


\end{enumerate}


