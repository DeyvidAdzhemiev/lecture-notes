\clearpage\section {Линеен едносвързан и двусвързан списък}

\subsection {Представяне на двусвързан списък}

\begin{mdframed}[hidealllines=true,backgroundcolor=gray!20]
Възел на линеен двусвързан списък представяме със следния шаблон на структура:
\begin{verbatim}
template <class T>
struct dllnode
{
  T data;
  dllnode<T> *next, *previous;
};
\end{verbatim}
Освен ако не е указано друго, задачите по-долу да се решат като се реализират методи на клас \code{DLList} със следния скелет:
\begin{verbatim}
template <class T>
class DLList
{
  //...
  private:
  dllnode<T> *first, *last;
};
\end{verbatim}
Преди да пристъпите към задачите, реализирайте подходящи контруктори, деструктор и оператор за присвояване на класа.
\end{mdframed}

\begin{figure}
    \centering
  
      \begin{tikzpicture}[auto, node distance=2cm,>=latex']
      \node[lnode] (n1) {\nodepart{two}1};
      \node[lnode, right of = n1] (n2) {\nodepart{two}2};
      \node[lnode, right of = n2] (n3) {\nodepart{two}3};
      \node[lnode, right of = n3] (n4) {\nodepart{two}4};
      \node[lnode, right of = n4] (n5) {\nodepart{two}5};
  
      \node[rectangle,left of = n1](start){};
  
      \draw[*->]  (start)-- (n1);
  
      \draw[*->] let \p1 = (n2.three), \p2 = (n1.center) in (\x1,\y2) -- (n3);
      \draw[*->] let \p1 = (n1.three), \p2 = (n1.center) in (\x1,\y2) -- (n2);
      \draw[*->] let \p1 = (n3.three), \p2 = (n1.center) in (\x1,\y2) -- (n4);
      \draw[*->] let \p1 = (n4.three), \p2 = (n1.center) in (\x1,\y2) -- (n5);
      \draw[*->,dashed] let \p1 = (n2.one), \p2 = (n1.center) in ([shift={(0.1cm,-0.1cm)}]\x1,\y2) |-([shift={(0,0.5cm)}]n2.north west) -- ([shift={(0,0.5cm)}]n1.north) -| ([shift={(-1cm,0cm)}]n1);
      \draw[*->,dashed] let \p1 = (n3.one), \p2 = (n2.center) in ([shift={(0.1cm,0.1cm)}]\x1,\y2) |-([shift={(0,-1cm)}]n3.north west) -- ([shift={(0,-1cm)}]n2.north) -| ([shift={(-1cm,0cm)}]n2);
      \draw[*->,dashed] let \p1 = (n4.one), \p2 = (n3.center) in ([shift={(0.1cm,-0.1cm)}]\x1,\y2) |-([shift={(0,0.5cm)}]n4.north west) -- ([shift={(0,0.5cm)}]n3.north) -| ([shift={(-1cm,0cm)}]n3);
      \draw[*->,dashed] let \p1 = (n5.one), \p2 = (n4.center) in ([shift={(0.1cm,0.1cm)}]\x1,\y2) |-([shift={(0,-1cm)}]n5.north west) -- ([shift={(0,-1cm)}]n4.north) -| ([shift={(-1cm,0cm)}]n4);
      \end{tikzpicture}
    \caption{Двусвързан списък}
    \label{fig:skiplist}
  \end{figure}
  

Следните задачи да се решат като упражнение за директно боравене с възлите на линеен двусвързан списък. Функциите (методите) да се тестват с подходящи тестове.

\begin{enumerate}

	\item  Да се дефинира функция \code{int count(dllnode<T>* l,int x)}, която преброява колко пъти елементът \code{x} се среща в списъка с първи елемент \code{l}.
	\item  Фунцкция \code{dllnode<int>* range (int x, int y)} която създава и връща първия елемент на списък с елементи $x, x+1, ..., y$, при положение, че $x \leq y$.
	\item  Да се дефинира функция \code{removeAll (dllnode<T>*\& l,const T\& x)}, която изтрива всички срещания на елемента \code{x} от списъка \code{l}.
	\item  Да се дефинира функция \code{void append(dllnode*<T>\& l1, dllnode<T>* l2)}, която добавя към края на списъка $l_1$ всички елементи на списъка $l_2$. Да се реализира съответен оператор \texttt{+=} в класа на списъка.
	\item  Да се дефинира функция \code{dllnode* concat(dllnode<T>* l1, dllnode<T>* l2)}, който съединява два списъка в нов, трети списък. Т.е. \code{concat($l_1,l_2$)} създава и връща нов списък от елементите на \code{$l_1$}, следвани от елементите на \code{$l_2$}. Да се реализира съответен оператор \texttt{+} в класа на списъка.
	\item  Да се дефинира функция \code{reverse}, която обръща реда на елементите на списък. Например, списъкът с елементи $1,2,3$ ще се преобразува до списъка с елементи $3,2,1$.
	\item Да се напише функция \code{void removeduplicates (dllnode *\&l)}, която изтрива всички дублиращи се елементи от списъка $l$.
  \item За шаблона \texttt{DLList} да се реалзиира изтриване на елемент по индекс.
\end{enumerate}

\subsection {Списъци и сложности}
\label{timing}
\begin{mdframed}[hidealllines=true,backgroundcolor=gray!20]
Функцията \code{std::clock()} от \code{<ctime>} връща в абстрактни единици времето, което е изминало от началото на изпълнение на програмата. Обикновено тази единица за време, наречена ``\code{tick}'', е фиксиран интервал ``реално'' време, който зависи от хардуера на системата и конфирграцията ѝ. Константата \code{CLOCKS\_PER\_SEC} дава броя \code{tick}-ове, които се съдържат в една секунда реално време.

Чрез следния примерен код може да се измери в милисекунди времето за изпълнение на програмния блок, обозначен с ``...''.
\begin{verbatim}
clock_t start = std::clock();
//...
clock_t end = std::clock();

long milliseconds = (double)(end-start)/
                    (CLOCKS_PER_SEC/1000.0);

\end{verbatim}
\end{mdframed}

\begin{enumerate}[resume]

\item За шаблона DLList да се дефинира метод \texttt{size\_t find(const T\& x)}, който намира поредния номер на елемента \texttt{x} в списъка (или връща размера на списъка, ако такъв елемент няма). Да се напише подходящ тест и да се изследва времевата сложност на метода емпирично.

\item Да се изпробват поне две различни стратегии за разширяване на динамичен масив (например, увеличаване на размера с 1 и с коефициент). Да напишат подходящи тестове и да се сравнят производителностите на двата подхода емпирично.

\end{enumerate}


\subsection{SList (опростен вариант на Skip List)}

\begin{mdframed}[hidealllines=true,backgroundcolor=gray!20]
Разглеждаме \emph{опростена} реализация на структурата от данни Skip List (``Списък с прескачене, СП''). Възелът на линейния едносвързан списък разширяваме с още един указател към следващ елемент:

\begin{verbatim}
template <class T>
struct lnode
{
  T data;
  lnode<T> *next, *skip;
};
\end{verbatim}
Както и при стандартния едносвързан списък, всеки от елментите на СП съдържа в указателя \code{next} адреса на непосредствения си съсед. Елементите на списъка са под дадена наредба. Някои от елементите могат да съдържат в указателя \code{skip} дреса на друг елемент, намиращ се по-напред в редицата от елементи (вж. Фигура \ref{fig:skiplist}). Например, нека имаме СП с $n$ елемента в нарастващ ред. Ако списъкът е построен така, че всеки $\sqrt{n}$-ти елемент има указател към следващия  $\sqrt{n}$-ти елемент, то търсенето на подсписъка, съдържащ даден елемент, ще бъде със сложност $O(\sqrt{n})$. Търсенето в рамките на подсписъка с $\sqrt{n}$ елемента остава линейно. Идеята може да се продължи така, че всеки елемент да може да има и по-голям брой указатели към елементи все по-напред в СП, но за нашите цели ще се ограничим до описания прост СП.

Следващите задачи изискват реализация на клас \code{SList} с основните му канонични методи и метод за построяване на ``бързите връзки''. Реализирайте обиновен метод за вмъкване на елементи \code{insertSorted}, който вмъква елементи грижейки се само за непосредствените връзки (\code{next}), и метод \code{speedup}, който построява бързите връзки в списъка, след като в него са вмъкнати определен брой елементи.
\end{mdframed}

\begin{figure}
  \centering

    \begin{tikzpicture}[auto, node distance=2cm,>=latex']
    \node[lnode] (n1) {\nodepart{two}1};
    \node[lnode, right of = n1] (n2) {\nodepart{two}2};
    \node[lnode, right of = n2] (n3) {\nodepart{two}3};
    \node[lnode, right of = n3] (n4) {\nodepart{two}4};
    \node[lnode, right of = n4] (n5) {\nodepart{two}5};

    \node[rectangle,left of = n1](start){};

    \draw[*->]  (start)-- (n1);

    \draw[*->] let \p1 = (n2.three), \p2 = (n1.center) in (\x1,\y2) -- (n3);
    \draw[*->] let \p1 = (n1.three), \p2 = (n1.center) in (\x1,\y2) -- (n2);
    \draw[*->] let \p1 = (n3.three), \p2 = (n1.center) in (\x1,\y2) -- (n4);
    \draw[*->] let \p1 = (n4.three), \p2 = (n1.center) in (\x1,\y2) -- (n5);
    \draw[*->,dashed] let \p1 = (n1.one), \p2 = (n1.center) in ([shift={(0.1cm,-0.1cm)}]\x1,\y2) |-([shift={(0,0.5cm)}]n1.north east) -- ([shift={(0,0.5cm)}]n3.north) -| (n3);
    \draw[*->,dashed] let \p1 = (n3.one), \p2 = (n3.center) in ([shift={(0.1cm,0.1cm)}]\x1,\y2) |-([shift={(0,-0.5cm)}]n3.south east) -- ([shift={(0,-0.5cm)}]n5.south) -| (n5);
    \end{tikzpicture}
  \caption{Списък с прескачане}
  \label{fig:skiplist}
\end{figure}

\begin{enumerate}[resume]


  \item  Да се реализират конструктор за копиране и оператор на присвояване на \code{SList}, които репликират и бързите връзки.
  \item Да се подобри методът за вмъкване на елемент \code{insertSorted}. Ако при вмъкване на нов елемент някой подсписък (обособен от дадена бърза вързка) получи повече от $2\sqrt(n)$ елемента, да се добави нова бърза връзка така, че подсписъка да се раздели на два подсписъка.
	\item  Да се извърши времево измерване на проблема за търсене на елемент в подреден \code{SList}, както е обяснено в Секция \ref{timing}, и да се изобрази чрез графика. Да се извършат емпирични сравнения на производителността на търсенете със и без оптимизацията.

\end{enumerate}


\pagebreak

\subsection {Итератори за линейни СД}
\label{iterators1}
Следните задачи да се решат като упражнение за работа с итератори. Задачите изискват реализация на клас линеен двусвързан списък и \code{forward} итератор за него. Всяка функциия да се тества с подходящи тестове.


\begin{enumerate}[resume]

	\item Да се разшири интераторът на двусвързан списък така, че да поддържа оператора за стъпка назад \texttt{-{}-}.

	\item Да се напише функция \code{bool duplicates (...)}, която проверява дали в контейнер има дублиращи се елементи.

	\item Да се напише фунцкия \code{bool issorted (...)}, която проверява дали елементите на даден контейнер са подредени в нарастващ или в намаляващ ред.

	\item Да се напише фунцкия \code{bool palindrom (...)}, която проверява дали редицата от елементите на даден контейнер обрзува палиндром (т.е. дали се чете еднакво както отляво надясно така и отдяно наляво).

	\item Да се реализира константен итератор за двусвързани списъци и горните функции да се преработят така, че да могат да работят с константни итератори.

    

\end{enumerate}

\subsection {Функции от високо ниво и оператори над итератори}

\begin{mdframed}[hidealllines=true,backgroundcolor=gray!20]
  Нека ``поредица'' да наричаме последователни елементи на някакъв контейнер, зададени чрез итератори към началото и края на последователността. С помощта на следния шаблон:
  \begin{verbatim}
template <class Iterator>
class Sequence{
    public:
        Sequence (const Iterator &b, 
                  const Iterator &e):_begin(b), _end (e){}
        Iterator begin()
        {return _begin;}
        Iterator end()
        {return _end;}
    private:
        Iterator _begin;
        Iterator _end;
};
  \end{verbatim}

  става възможно не само да оформим двойката начало-край в общ обект, но и да итерираме съответната поредица с цикъл \code{for}. Ако \code{begin} и \code{end} са съответните итератори към елементи от тип \code{E} и имаме обекта \code{Sequence<SomeIterator>(begin,end)}, то можем да направим обхождането:
 \begin{verbatim}
for (E& x : seq){...}   
 \end{verbatim}
 
 На лекции разглеждаме деструктивен вариант на функцията от високо ниво \code{map}, извършваща еднотипна трансформация на елементите на поредица, като се абстрахира напълно от контейнера:
  
\begin{verbatim}
template <class Iterator, class Element>
void map(Sequence<Iterator> seq,
          Element (*f)(const Element &))
{
    for (Element& e: seq)
    {e = f (e);}    
}
\end{verbatim}

  Може да разгледаме и фунцкията за агрегации \code{reduce}, позната от функционалното програмиране: 
\begin{verbatim}
template <class Iterator, class Element>
Element reduce(Sequence<Iterator> seq,
                Element (*op)(const Element &, const Element &),
                Element null_val)
{
    Element accum = null_val;
    for (Element e : seq)
    { accum = op(accum, e); }
    return accum;
}
\end{verbatim}
Възможно е също да реализираме операция с поредица, която изменя броя или реда на елементите ѝ, отново без знание за подлежащия контейнер. Такава е например операцията \code{filter}. Това налага да се конструира нова поредица, като по някакъв начин се измени поведението на итераторите на оригиналната поредица. Например, реализирания на лекции \code{FilterIterator} ``изменя'' даден друг итератор като ``прескача'' елементите, които не удовлетворяват даден предикат. По този начин можем да дефинираме:
\begin{verbatim}
template <class Iterator, class Element>
Sequence<FilterIterator<Iterator,Element>> 
    filter(Sequence<Iterator> &seq,
           bool (*pred)(const Element &))
{
  FilterIterator<Iterator,Element> begin (seq.begin(),seq.end(),pred);
  FilterIterator<Iterator,Element> end (seq.end(),seq.end(),pred);

  return Sequence<FilterIterator<Iterator, Element>> (begin, end);
}    
  \end{verbatim}
  Използването на \code{Sequence} както за параметър, така и за резултат на тези функции, ни позволява да ги използваме за обхождане на новополучените подредици. Също така, можем да композираме функциите:
  \begin{verbatim}
for (E x : filter (seq, even)) {...обработка само на четните елементи на seq...}
reduce(filter(seq,even),plus,0);//сума на четните елементи на seq 
  \end{verbatim}
Ако по подобие на \code{FilterIterator} реализираме \code{MapIterator}, можем да напраивм функционален вариант на \code{map}, \code{mapf}. Това ще ни позволи на намерим сумата на четните елементи на поредица, след като ги увеличим с единица, по следния начин:
\begin{verbatim}
reduce(mapf(filter(seq,even), inc), plus, 0)  
\end{verbatim}
\end{mdframed}

\begin{enumerate}[resume]
  \item По аналогия на дадените примери да се дефинира функция \code{append(a,b)}, която създава нова поредица чрез слепване на поредиците \code{a} и \code{b}.
  \item По аналогия на дадените примери да се дефинира функция \code{combine(a,b,f)}, която създава нова поредица от стойностите на двуместната функция \code{f}, приложена върху съответните елементи на \code{a} и \code{b}. Функцията да се демомстрира като се съберат съответните елементи на две редици.
  \item По аналогия на дадените примери да се дефинира функция \code{merge(a,b)}. Ако $a=a_1,...,a_k$, $b=b_1,...,b_l$, то $merge(a,b)=a_1,b_1,a_2,b_2,...$. 
  \item По аналогия на дадените примери да се дефинира функция \code{zip(a,b)}, която създава нова поредица от двойките (\code{std::pair}) от стойностите на съответните елементи на \code{a} и \code{b}. 
\end{enumerate}